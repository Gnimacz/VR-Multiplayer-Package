using System;
using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Unity.Netcode;
using Unity.Netcode.Transports.UTP;
using Unity.Services.Authentication;
using Unity.Services.Core;
using Unity.Services.Lobbies;
using Unity.Services.Lobbies.Models;
using Unity.Services.Relay;
using Unity.Services.Relay.Models;
using UnityEngine;

/// <summary>
/// LobbyManager is responsible for creating, managing, and joining multiplayer lobbies using Unity Services.
/// It integrates with Unity Lobby and Relay services to handle lobby lifecycle, relay allocation,
/// and network transport configuration for multiplayer sessions.
/// </summary>
public class LobbyManager : MonoBehaviour
{
    /// <summary>
    /// Represents the name of the lobby used during its creation or configuration.
    /// This name is displayed publicly and helps identify the lobby in the service.
    /// </summary>
    [Header("Lobby Settings")]
    [SerializeField] private string lobbyName = "Lobby Name";

    /// <summary>
    /// Represents a password used to secure the current lobby.
    /// </summary>
    /// <remarks>
    /// This variable is utilized to determine if the lobby requires a password and to validate
    /// users attempting to join. The password is hashed before being added to the lobby's data
    /// when the lobby is created or validated.
    /// </remarks>
    [SerializeField] private string lobbyPassword = string.Empty;

    /// <summary>
    /// Indicates whether the lobby is private.
    /// When set to <c>true</c>, the lobby requires a password for access.
    /// If <c>false</c>, the lobby is open to all players without a password.
    /// </summary>
    [SerializeField] private bool isPrivate = false;

    /// <summary>
    /// Represents the maximum number of players that can join a lobby.
    /// This value is used to define the upper limit for player capacity in the lobby
    /// when creating or hosting a session.
    /// </summary>
    [SerializeField] private int maxPlayers = 4;

    /// <summary>
    /// Represents a reference to the UnityTransport component used for
    /// managing transport-related functionality in Unity Netcode.
    /// </summary>
    /// <remarks>
    /// This variable is used to configure and handle the Unity transport layer,
    /// such as setting up relay data for hosting or joining a networked session.
    /// It is critical for establishing connectivity via Unity's Relay and Netcode services.
    /// </remarks>
    [Header("References")]
    [SerializeField] private UnityTransport transport;

    /// <summary>
    /// Gets the room code associated with the current lobby or relay session.
    /// </summary>
    /// <remarks>
    /// The room code is a unique identifier generated by the Relay service used for clients
    /// to join a session. It is set during the creation of a host relay session and retrieved
    /// from the Relay service. It is stored as part of the lobby data to allow other players
    /// to join.
    /// </remarks>
    public string RoomCode { get; private set; } = string.Empty;

    /// <summary>
    /// Represents the currently active lobby instance within the LobbyManager.
    /// This property holds the data of the lobby the player has created or joined,
    /// including its ID, associated settings, and player information.
    /// The property is updated when a lobby is successfully created, joined, or fetched.
    /// </summary>
    public Lobby CurrentLobby { get; private set; }

    /// <summary>
    /// Defines the time interval, in seconds, between each periodic heartbeat or keep-alive invocation
    /// for maintaining the lobby's active state.
    /// </summary>
    /// <remarks>
    /// This constant ensures that the lobby remains accessible by sending periodic updates
    /// to the lobby service. It is used in the <c>PeriodicHeartbeat</c> and <c>PeriodicKeepAlive</c> coroutines.
    /// </remarks>
    private const float HeartbeatInterval = 5f;

    /// <summary>
    /// A reference to the coroutine responsible for performing periodic heartbeat updates for the lobby.
    /// The heartbeat mechanism ensures the lobby remains active and visible in the matchmaking service.
    /// This coroutine runs periodically at a defined interval to send update requests to the lobby service.
    /// </summary>
    private Coroutine heartbeatCoroutine;

    /// <summary>
    /// Represents a coroutine responsible for continuously sending keep-alive signals
    /// to ensure the lobby remains active and does not expire due to inactivity.
    /// </summary>
    private Coroutine keepAliveCoroutine;

    /// <summary>
    /// Initializes the LobbyManager by performing asynchronous setup tasks.
    /// This primarily involves initializing Unity Services and signing in the user
    /// anonymously to enable usage of services such as Lobbies and Relay.
    /// </summary>
    /// <remarks>
    /// This method is called automatically when the GameObject containing this
    /// script is created or enabled in the Unity scene. It ensures that the
    /// necessary services are initialized before any other operations in the
    /// LobbyManager can proceed.
    /// </remarks>
    private async void Awake()
    {
        await InitializeServicesAsync();
    }

    /// Asynchronously initializes Unity Services and authenticates the user anonymously.
    /// This method is responsible for initializing the Unity Services SDK and
    /// automatically signing in the user anonymously using Unity's Authentication Service.
    /// It should be invoked before accessing other Unity services to ensure they are properly initialized.
    /// <returns>
    /// A Task representing the asynchronous operation of initializing the services and authenticating the user.
    /// </returns>
    private async Task InitializeServicesAsync()
    {
        await UnityServices.InitializeAsync();
        await AuthenticationService.Instance.SignInAnonymouslyAsync();
    }

    #region Host Lobby

    /// Starts a host relay session and creates a lobby.
    /// The method initializes a relay allocation, generates a room code,
    /// configures the Unity Transport for hosting, creates a lobby using Unity Services,
    /// and starts the host network. It also sets up periodic heartbeat and keep-alive coroutines
    /// to maintain the lobby session.
    /// <returns>
    /// A task that represents the asynchronous operation of starting the host relay and lobby.
    /// </returns>
    public async Task StartHostRelayAsync()
    {
        try
        {
            var allocation = await RelayService.Instance.CreateAllocationAsync(maxPlayers);
            RoomCode = await RelayService.Instance.GetJoinCodeAsync(allocation.AllocationId);
            ConfigureTransportHost(allocation);

            CurrentLobby = await LobbyService.Instance.CreateLobbyAsync(
                lobbyName,
                maxPlayers,
                BuildCreateOptions(RoomCode)
            );

            Debug.Log($"Lobby created (ID: {CurrentLobby.Id}), RoomCode: {RoomCode}");

            heartbeatCoroutine = StartCoroutine(PeriodicHeartbeat(CurrentLobby.Id, HeartbeatInterval));
            keepAliveCoroutine = StartCoroutine(PeriodicKeepAlive(CurrentLobby.Id, HeartbeatInterval));

            NetworkManager.Singleton.StartHost();
        }
        catch (Exception ex)
        {
            Debug.LogError($"Failed to start host relay: {ex.Message}");
        }
    }

    /// Builds the options required to create a lobby, including settings and metadata.
    /// <param name="roomCode">The RoomCode to associate with the lobby, typically used for joining.</param>
    /// <returns>A CreateLobbyOptions object containing the necessary options and metadata for creating a lobby.</returns>
    private CreateLobbyOptions BuildCreateOptions(string roomCode)
    {
        var data = new Dictionary<string, DataObject>
        {
            { "RoomCode", new DataObject(DataObject.VisibilityOptions.Public, roomCode) },
            { "HasPassword", new DataObject(DataObject.VisibilityOptions.Public, (!string.IsNullOrEmpty(lobbyPassword)).ToString().ToLower()) }
        };

        if (isPrivate && !string.IsNullOrEmpty(lobbyPassword))
        {
            string hashed = HashString(lobbyPassword);
            data.Add("HashedPassword", new DataObject(DataObject.VisibilityOptions.Member, hashed));
        }

        return new CreateLobbyOptions { Data = data };
    }

    /// Configures the Unity transport to host a relay connection using the provided allocation details.
    /// <param name="allocation">The allocation data provided by the Relay service, containing necessary connection details including server IP, port, allocation ID, connection data, and keys.</param>
    private void ConfigureTransportHost(Allocation allocation)
    {
        transport.SetHostRelayData(
            allocation.RelayServer.IpV4,
            (ushort)allocation.RelayServer.Port,
            allocation.AllocationIdBytes,
            allocation.Key,
            allocation.ConnectionData
        );
    }

    #endregion

    #region Join Lobby

    /// Asynchronously joins a relay using the provided lobby ID.
    /// <param name="lobbyId">The unique identifier of the lobby to join.</param>
    /// <returns>A task representing the asynchronous operation of joining the relay.</returns>
    public async Task JoinRelayAsync(string lobbyId)
    {
        try
        {
            var lobby = await LobbyService.Instance.GetLobbyAsync(lobbyId);
            await AttemptJoinAsync(lobby);
        }
        catch (Exception ex)
        {
            Debug.LogError($"Error joining relay: {ex.Message}");
        }
    }

    /// Attempts to quickly join an available multiplayer relay lobby asynchronously.
    /// This method utilizes the Unity Lobby Service to join the first available lobby
    /// that matches criteria defined by the service. If successful, the user will be
    /// connected to the selected lobby and the associated relay allocation.
    /// <returns>Returns a Task that completes when the join operation is finished, either successfully or with an error.</returns>
    public async Task QuickJoinRelayAsync()
    {
        try
        {
            var lobby = await LobbyService.Instance.QuickJoinLobbyAsync();
            await AttemptJoinAsync(lobby);
        }
        catch (Exception ex)
        {
            Debug.LogError($"Error in quick join relay: {ex.Message}");
        }
    }

    /// Attempts to join a specified lobby and establishes client connections for network communication.
    /// <param name="lobby">
    /// An instance of the lobby to join. It must contain the necessary connection data such as the RoomCode.
    /// </param>
    /// <returns>
    /// A Task representing the asynchronous operation of joining the lobby.
    /// The Task is completed when the connection to the relay server is established and the client starts.
    /// </returns>
    private async Task AttemptJoinAsync(Lobby lobby)
    {
        if (!await ValidatePasswordAsync(lobby)) return;

        CurrentLobby = await LobbyService.Instance.JoinLobbyByIdAsync(lobby.Id);
        CurrentLobby = await LobbyService.Instance.GetLobbyAsync(CurrentLobby.Id);

        if (!CurrentLobby.Data.TryGetValue("RoomCode", out var codeObj))
        {
            Debug.LogError("No RoomCode in lobby data.");
            return;
        }

        RoomCode = codeObj.Value;
        var allocation = await RelayService.Instance.JoinAllocationAsync(RoomCode);
        ConfigureTransportClient(allocation);

        NetworkManager.Singleton.StartClient();
    }

    /// Validates the password for a given lobby by comparing the provided input password
    /// with the hashed password stored in the lobby's data. If the lobby requires a password
    /// and the provided password is missing or invalid, it will log an error and leave the lobby.
    /// <param name="lobby">The lobby instance to validate the password against.</param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task results in a boolean indicating
    /// whether the password validation was successful (true) or failed (false).
    /// </returns>
    private async Task<bool> ValidatePasswordAsync(Lobby lobby)
    {
        if (lobby.Data.TryGetValue("HasPassword", out var hasPwd) && hasPwd.Value == "true")
        {
            if (string.IsNullOrEmpty(lobbyPassword))
            {
                Debug.LogError("Password required but none provided.");
                await LeaveLobbyAsync(lobby.Id);
                return false;
            }

            string hashed = HashString(lobbyPassword);
            if (!lobby.Data.TryGetValue("HashedPassword", out var stored) || stored.Value != hashed)
            {
                Debug.LogError("Invalid lobby password.");
                await LeaveLobbyAsync(lobby.Id);
                return false;
            }
        }
        return true;
    }

    /// Configures the UnityTransport client with Relay allocation settings provided by the Relay service.
    /// <param name="allocation">
    /// The Relay join allocation instance containing the necessary data to configure the client connection,
    /// such as server IP, port, allocation ID, connection data, and host connection data.
    /// </param>
    private void ConfigureTransportClient(JoinAllocation allocation)
    {
        transport.SetClientRelayData(
            allocation.RelayServer.IpV4,
            (ushort)allocation.RelayServer.Port,
            allocation.AllocationIdBytes,
            allocation.Key,
            allocation.ConnectionData,
            allocation.HostConnectionData
        );
    }

    #endregion

    #region Lobby Maintenance

    /// Sends a periodic heartbeat to the server to keep the specified lobby active.
    /// <param name="lobbyId">The unique identifier of the lobby to send the heartbeat to.</param>
    /// <param name="interval">The interval in seconds at which the heartbeat should be sent.</param>
    /// <returns>An IEnumerator used to run the coroutine.</returns>
    private IEnumerator PeriodicHeartbeat(string lobbyId, float interval)
    {
        var wait = new WaitForSecondsRealtime(interval);
        while (true)
        {
            LobbyService.Instance.SendHeartbeatPingAsync(lobbyId);
            yield return wait;
        }
    }

    /// Periodically sends keep-alive updates to the lobby to prevent it from expiring.
    /// <param name="lobbyId">
    /// The unique identifier of the lobby to keep alive.
    /// </param>
    /// <param name="interval">
    /// The interval, in seconds, between each keep-alive update.
    /// </param>
    /// <return>
    /// An IEnumerator for use with Unity's coroutine system.
    /// </return>
    private IEnumerator PeriodicKeepAlive(string lobbyId, float interval)
    {
        var wait = new WaitForSecondsRealtime(interval);
        while (true)
        {
            try
            {
                LobbyService.Instance.UpdateLobbyAsync(lobbyId, new UpdateLobbyOptions());
            }
            catch (LobbyServiceException ex)
            {
                Debug.LogError($"Keep-alive failed: {ex.Message}");
                yield break;
            }
            yield return wait;
        }
    }

    #endregion

    /// <summary>
    /// Handles any necessary cleanup when the application quits.
    /// Checks if the player is currently in a lobby and removes the player from it asynchronously
    /// to ensure proper disconnection from the lobby service.
    /// </summary>
    private async void OnApplicationQuit()
    {
        if (CurrentLobby != null)
        {
            await LeaveLobbyAsync(CurrentLobby.Id);
        }
    }

    /// Removes the current player from the lobby asynchronously based on the provided lobby ID.
    /// <param name="lobbyId">The unique identifier of the lobby the player is leaving.</param>
    /// <returns>A task representing the asynchronous operation of leaving the lobby.</returns>
    private async Task LeaveLobbyAsync(string lobbyId)
    {
        await LobbyService.Instance.RemovePlayerAsync(lobbyId, AuthenticationService.Instance.PlayerId);
    }

    #region Utilities

    /// <summary>
    /// Computes the SHA256 hash of the given input string and returns the result as a hexadecimal string.
    /// </summary>
    /// <param name="input">The input string to be hashed.</param>
    /// <returns>A hexadecimal string representing the SHA256 hash of the input string.</returns>
    private static string HashString(string input)
    {
        using var sha = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(input);
        var hash = sha.ComputeHash(bytes);
        return BitConverter.ToString(hash).Replace("-", string.Empty);
    }

    #endregion

    #region Editor Helpers

    // Exposed to UI
    /// <summary>
    /// Sets the name of the lobby.
    /// </summary>
    /// <param name="name">The new name to assign to the lobby.</param>
    public void SetLobbyName(string name) => lobbyName = name;

    /// <summary>
    /// Sets the password for the current lobby.
    /// </summary>
    /// <param name="password">The password to set for the lobby. If empty or null, the lobby will not require a password.</param>
    public void SetLobbyPassword(string password) => lobbyPassword = password;

    /// <summary>
    /// Displays the on-screen keyboard for user input.
    /// </summary>
    /// <remarks>
    /// This method opens a touch screen keyboard with the default configuration.
    /// The keyboard is pre-filled with the value of the RoomCode property and allows
    /// users to input or modify text. It is specifically optimized for scenarios where
    /// the user needs to enter or edit room codes.
    /// </remarks>
    public void ShowKeyboard()
    {
        TouchScreenKeyboard.Open(RoomCode, TouchScreenKeyboardType.Default, false, false, false, false, "Enter Room Code");
    }

    #endregion
}
